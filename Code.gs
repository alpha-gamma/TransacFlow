/**
 * TransacFlow - Flow your transactions from Gmail to Sheets
 * 
 * âš ï¸ SETUP REQUIRED:
 * 1. Update Config.gs with your Sheet ID
 * 2. Customize BankPatterns.gs if needed
 * 3. Run setupAutomation() to start
 * 
 * âš ï¸ DO NOT EDIT THIS FILE (unless you know what you're doing)
 * â†’ All configurations are in Config.gs
 * â†’ Bank patterns are in BankPatterns.gs
 * 
 * ðŸ“‹ MAIN FUNCTIONS (Run these):
 * - setupAutomation()           â†’ Initial setup & create triggers
 * - processTransactionEmails()  â†’ Manual run (also auto-runs every 10 min)
 * - refreshAllNicknames()       â†’ Update all transactions with latest nicknames
 * 
 * ðŸ§ª TESTING FUNCTIONS:
 * - test_SingleEmail()          â†’ Test parsing of one email
 * - test_WriteToSheet()         â†’ Test parsing + writing to sheet
 * 
 * ðŸ” DIAGNOSTIC FUNCTIONS:
 * - debug_SearchQuery()         â†’ Show current search query
 * - debug_EmailSearch()         â†’ Diagnose email search issues
 * - debug_ShowRawEmail()        â†’ Show raw email content for pattern debugging
 * 
 * â„¹ï¸ ACCOUNT NICKNAMES:
 * - Managed in "Account Nicknames" sheet (auto-created)
 * - Edit "Custom Nickname" column to customize names
 * - Changes automatically update all transactions!
 * 
 * @version 1.1.0
 * @author Aakash Goel
 * @license MIT
 * @repository https://github.com/alpha-gamma/transacflow
 */

// ==================== UTILITIES ====================

/**
 * Logger class for centralized logging
 */
class Logger {
  constructor(logLevel = 'INFO') {
    this.logLevel = logLevel;
    this.levels = { 'DEBUG': 0, 'INFO': 1, 'WARN': 2, 'ERROR': 3 };
  }
  
  shouldLog(level) {
    return this.levels[level] >= this.levels[this.logLevel];
  }
  
  formatMessage(level, message) {
    const timestamp = new Date().toISOString();
    return `[${timestamp}] [${level}] ${message}`;
  }
  
  debug(message) {
    if (this.shouldLog('DEBUG')) console.log(this.formatMessage('DEBUG', message));
  }
  
  info(message) {
    if (this.shouldLog('INFO')) console.log(this.formatMessage('INFO', message));
  }
  
  warn(message) {
    if (this.shouldLog('WARN')) console.warn(this.formatMessage('WARN', message));
  }
  
  error(message) {
    if (this.shouldLog('ERROR')) console.error(this.formatMessage('ERROR', message));
  }
  
  success(message) {
    console.log(this.formatMessage('SUCCESS', `âœ“ ${message}`));
  }
  
  section(title) {
    if (this.shouldLog('INFO')) {
      console.log('\n' + '='.repeat(50));
      console.log(`  ${title}`);
      console.log('='.repeat(50) + '\n');
    }
  }
  
  object(label, obj) {
    if (this.shouldLog('DEBUG')) {
      console.log(`${label}:`);
      console.log(JSON.stringify(obj, null, 2));
    }
  }
}

/**
 * TextUtils class for text processing
 */
class TextUtils {
  static normalizeAmount(amountStr) {
    if (!amountStr) return null;
    try {
      // Get currency format from config
      const currencyFormat = getCurrencyFormat();
      
      let cleaned = amountStr;
      
      // Remove currency symbols based on configuration
      currencyFormat.symbols.forEach(symbol => {
        // Escape special regex characters
        const escapedSymbol = symbol.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        cleaned = cleaned.replace(new RegExp(escapedSymbol, 'gi'), '');
      });
      
      // Remove thousands separator
      cleaned = cleaned.replace(new RegExp('\\' + currencyFormat.thousandsSeparator, 'g'), '');
      
      // Remove whitespace
      cleaned = cleaned.replace(/\s+/g, '').trim();
      
      const amount = parseFloat(cleaned);
      return isNaN(amount) ? null : amount.toFixed(2);
    } catch (error) {
      console.error(`Error normalizing amount: ${error.message}`);
      return null;
    }
  }
  
  static cleanText(text) {
    if (!text) return null;
    return text
      .replace(/[\r\n]+/g, ' ')
      .replace(/\s{2,}/g, ' ')
      .replace(/\t+/g, ' ')
      .trim();
  }
  
  static truncate(text, maxLength = 100) {
    if (!text || text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
  }
}

/**
 * DateUtils class for date processing
 */
class DateUtils {
  static parseDate(dateStr, format = null) {
    if (!dateStr) return null;
    
    try {
      let cleanDateStr = dateStr.replace(/\s*(IST|GMT|UTC|EST|PST)\s*$/i, '').trim();
      
      // If format is specified, use format-specific parser
      if (format) {
        let date = null;
        
        if (format === 'DD-MM-YYYY') {
          // Try DD-MM-YYYY formats and also DD MMM, YYYY format
          date = DateUtils.parseDDMMYYYYComma(cleanDateStr) || 
                 DateUtils.parseDDMMYYYY(cleanDateStr) ||
                 DateUtils.parseDDMMMYYYY(cleanDateStr);
        } else if (format === 'DD-MM-YY') {
          // Try DD-MM-YY format (2-digit year)
          date = DateUtils.parseDDMMYY(cleanDateStr);
        } else if (format === 'DD-MMM-YYYY' || format === 'DD MMM YYYY') {
          date = DateUtils.parseDDMMMYYYY(cleanDateStr);
        } else if (format === 'MMM DD, YYYY') {
          // Try MMM DD, YYYY format (e.g., Nov 24, 2025)
          date = DateUtils.parseMMMDDYYYY(cleanDateStr);
        }
        
        if (date && !isNaN(date.getTime())) return date;
      }
      
      // Fallback: Try standard Date() constructor
      let date = new Date(cleanDateStr);
      if (!isNaN(date.getTime())) return date;
      
      // Fallback: Try all parsers
      const parsers = [
        DateUtils.parseDDMMYYYYComma,
        DateUtils.parseDDMMYYYY,
        DateUtils.parseDDMMMYYYY
      ];
      
      for (const parser of parsers) {
        date = parser(cleanDateStr);
        if (date && !isNaN(date.getTime())) return date;
      }
      
      console.warn(`Could not parse date: ${dateStr}, using current time`);
      return new Date();
      
    } catch (error) {
      console.error(`Date parsing error: ${error}`);
      return new Date();
    }
  }
  
  static parseDDMMYYYYComma(dateStr) {
    // DD-MM-YYYY format (e.g., 09-11-2025 = 9 Nov 2025)
    const match = dateStr.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4}),?\s*(\d{1,2}):(\d{2}):?(\d{2})?/);
    if (match) {
      const day = parseInt(match[1]);
      const month = parseInt(match[2]);
      const year = parseInt(match[3]);
      const hour = parseInt(match[4]);
      const minute = parseInt(match[5]);
      const second = match[6] ? parseInt(match[6]) : 0;
      
      // JavaScript Date constructor: new Date(year, monthIndex, day, ...)
      // monthIndex is 0-based: 0=Jan, 1=Feb, ..., 11=Dec
      return new Date(year, month - 1, day, hour, minute, second);
    }
    return null;
  }
  
  static parseDDMMYYYY(dateStr) {
    // DD-MM-YYYY format with optional am/pm
    // Handles: "22-11-2025 03:05:35 pm" or "22-11-2025 15:05:35"
    const match = dateStr.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})\s+(\d{1,2}):(\d{2}):?(\d{2})?\s*([ap]m)?/i);
    if (match) {
      const day = parseInt(match[1]);
      const month = parseInt(match[2]);
      const year = parseInt(match[3]);
      let hour = parseInt(match[4]);
      const minute = parseInt(match[5]);
      const second = match[6] ? parseInt(match[6]) : 0;
      const meridiem = match[7] ? match[7].toLowerCase() : null;
      
      // Convert to 24-hour format if am/pm is present
      if (meridiem) {
        if (meridiem === 'pm' && hour < 12) {
          hour += 12;
        } else if (meridiem === 'am' && hour === 12) {
          hour = 0;
        }
      }
      
      return new Date(year, month - 1, day, hour, minute, second);
    }
    return null;
  }
  
  static parseDDMMYY(dateStr) {
    // DD-MM-YY format (2-digit year, e.g., 16-11-25 = 16 Nov 2025)
    const match = dateStr.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})$/);
    if (match) {
      const day = parseInt(match[1]);
      const month = parseInt(match[2]);
      let year = parseInt(match[3]);
      
      // Convert 2-digit year to 4-digit
      // Assume 00-49 = 2000-2049, 50-99 = 1950-1999
      year = year < 50 ? 2000 + year : 1900 + year;
      
      return new Date(year, month - 1, day);
    }
    return null;
  }
  
  static parseDDMMMYYYY(dateStr) {
    // Format 1: DD-MMM-YYYY (e.g., 01-Dec-2025 14:30:45)
    let match = dateStr.match(/(\d{1,2})[\/\-]([A-Za-z]{3})[\/\-](\d{4})\s*(\d{1,2}):(\d{2}):?(\d{2})?/);
    if (match) {
      const [, day, monthName, year, hour, minute, second] = match;
      const date = new Date(`${monthName} ${day}, ${year} ${hour}:${minute}:${second || '00'}`);
      return !isNaN(date.getTime()) ? date : null;
    }
    
    // Format 2: DD MMM, YYYY at HH:MM:SS (e.g., 26 Nov, 2025 at 12:01:34)
    match = dateStr.match(/(\d{1,2})\s+([A-Za-z]{3}),\s+(\d{4})\s+at\s+(\d{1,2}):(\d{2}):?(\d{2})?/);
    if (match) {
      const [, day, monthName, year, hour, minute, second] = match;
      const date = new Date(`${monthName} ${day}, ${year} ${hour}:${minute}:${second || '00'}`);
      return !isNaN(date.getTime()) ? date : null;
    }
    
    return null;
  }
  
  static parseMMMDDYYYY(dateStr) {
    // Format: MMM DD, YYYY HH:MM:SS (e.g., Nov 24, 2025 07:05:19)
    // Also handles: MMM DD, YYYY at HH:MM:SS
    const match = dateStr.match(/([A-Za-z]{3})\s+(\d{1,2}),\s+(\d{4})(?:\s+at)?\s+(\d{1,2}):(\d{2}):?(\d{2})?/);
    if (match) {
      const [, monthName, day, year, hour, minute, second] = match;
      const date = new Date(`${monthName} ${day}, ${year} ${hour}:${minute}:${second || '00'}`);
      return !isNaN(date.getTime()) ? date : null;
    }
    
    return null;
  }
}

// ==================== BUILT-IN BANK PATTERNS ====================

/**
 * Manager for bank patterns (built-in + custom)
 * Encapsulates pattern loading logic
 */
class BankPatternManager {
  static getDefaultPatterns() {
    return [
      // ============================================
      // HDFC BANK
      // ============================================
      {
        name: 'HDFC Bank UPI - Debit Account',
        senderPattern: 'alerts@hdfcbank\\.net',
        subjectPattern: 'You have done a UPI txn',
        bodyPattern: 'has been debited from account \\d{4} to',
        
        amountPattern: 'Rs\\.\\s*([\\d,]+\\.?\\d*)\\s+has been debited from account',
        accountPattern: 'from\\s+account\\s+(\\d{4})',
        // Updated to handle hyphens in VPA (e.g., 9876543210-1@upibank)
        merchantPattern: 'to\\s+(?:VPA\\s+)?[\\w.-]+@\\w+\\s+([A-Za-z0-9][A-Za-z0-9\\s&\\.\\-\\*]+?)\\s+on',
        datePattern: 'on\\s+(\\d{2}[/-]\\d{2}[/-]\\d{2})',
        dateFormat: 'DD-MM-YY',
      },
      {
        name: 'HDFC Bank UPI - RuPay Credit Card',
        senderPattern: 'alerts@hdfcbank\\.net',
        subjectPattern: 'You have done a UPI txn',
        bodyPattern: 'has been debited from your HDFC Bank RuPay Credit Card',
        
        amountPattern: 'Rs\\.\\s*([\\d,]+\\.?\\d*)\\s+has been debited from your HDFC Bank RuPay Credit Card',
        accountPattern: 'from\\s+your\\s+HDFC\\s+Bank\\s+RuPay\\s+Credit\\s+Card\\s+(XX\\d{4})',
        merchantPattern: 'to\\s+[\\w.]+@\\w+\\s+([A-Za-z0-9][A-Za-z0-9\\s&\\.\\-\\*]+?)\\s+on',
        datePattern: 'on\\s+(\\d{2}[/-]\\d{2}[/-]\\d{2})',
        dateFormat: 'DD-MM-YY',
      },
      {
        name: 'HDFC Bank Credit Card',
        senderPattern: 'alerts@hdfcbank\\.net',
        subjectPattern: 'debited via Credit Card|Update on your HDFC Bank Credit Card',
        bodyPattern: 'Credit Card ending \\d{4}',
        
        amountPattern: '(?:for\\s+)?Rs\\.?\\s*([\\d,]+\\.?\\d*)',
        accountPattern: '[Cc](?:redit\\s+)?[Cc]ard\\s+ending\\s+(\\d{4})',
        merchantPattern: '(?:at\\s+|towards\\s+)([A-Za-z0-9][A-Za-z0-9\\s&\\.\\-\\*]+?)\\s+on',
        datePattern: 'on\\s+(\\d{2}[/-]\\d{2}[/-]\\d{4}\\s+\\d{2}:\\d{2}:\\d{2}|\\d{2}\\s+\\w{3},\\s+\\d{4}\\s+at\\s+\\d{2}:\\d{2}:\\d{2})',
        dateFormat: 'DD-MM-YYYY',
      },
      
      // ============================================
      // AXIS BANK - Credit Card
      // ============================================
      {
        name: 'Axis Bank Credit Card',
        senderPattern: 'alerts@axisbank\\.com',
        subjectPattern: 'spent on credit card|Transaction alert on Axis Bank Credit Card',
        bodyPattern: 'summary of your Axis Bank Credit Card Transaction|Thank you for using your Card|Thank you for using your credit card',
        
        amountPattern: '(?:Transaction\\s+Amount:\\s*|for\\s+)?(?:INR|Rs\\.?|â‚¹)\\s*([\\d,]+\\.?\\d*)',
        accountPattern: '(?:(?:Axis\\s+Bank\\s+)?[Cc]redit\\s+)?[Cc]ard\\s+(?:[Nn]o\\.?|ending)\\s*(XX\\d{4})',
        merchantPattern: '(?:Merchant\\s+Name:\\s*|at\\s+)([A-Za-z0-9][A-Za-z0-9\\s&\\.\\-]+?)(?:[\\r\\n]|\\s{2,}|\\s+on)',
        datePattern: '(?:Date\\s+&\\s+Time:\\s*|on\\s+)(\\d{2}[/-]\\d{2}[/-]\\d{4})[,\\s]+(\\d{2}:\\d{2}(?::\\d{2})?)(?:\\s+IST)?',
        dateFormat: 'DD-MM-YYYY',
      },

      // ============================================
      // INDUSIND BANK - Credit Card
      // ============================================
      {
        name: 'IndusInd Bank Credit Card',
        senderPattern: 'transactionalert@indusind\\.com',
        subjectPattern: 'Transaction Alert - IndusInd Bank Credit Card',
        bodyPattern: 'The transaction on your IndusInd Bank Credit Card',
        
        // "for INR 3,275.00 on" - handle commas and optional decimals
        amountPattern: 'for\\s+INR\\s+([\\d,]+(?:\\.\\d{2})?)\\s+on',
        
        // "ending 1234" - will be auto-prefixed with XX
        accountPattern: 'ending\\s+(\\d{4})',
        
        // "at Merchant Name is Approved" - match until " is "
        merchantPattern: 'at\\s+([A-Za-z0-9][^\\r\\n]+?)\\s+is\\s+Approved',
        
        // "on 22-11-2025 03:05:35 pm at"
        // Captures both date and time with am/pm
        datePattern: 'on\\s+(\\d{2}-\\d{2}-\\d{4})\\s+(\\d{2}:\\d{2}:\\d{2}\\s+[ap]m)',
        
        dateFormat: 'DD-MM-YYYY',
      },

      // ============================================
      // ICICI BANK - Credit Card
      // ============================================
      {
        name: 'ICICI Bank Credit Card',
        senderPattern: 'credit_cards@icicibank\\.com',
        subjectPattern: 'Transaction alert for your ICICI Bank Credit Card',
        bodyPattern: 'Your ICICI Bank Credit Card',
        
        // "INR 2,460.00" or "INR 2.00" - handle commas and decimals
        amountPattern: 'INR\\s+([\\d,]+\\.\\d{2})',
        
        // "XX1234" or "XX5678" - already includes XX prefix
        accountPattern: '(XX\\d{4})',
        
        // "Info: AMAZON PAY IN UTILITY" or "Info: UPI-123456789012-MERCHANT NAME"
        // Match everything after "Info: " until period or end of line
        merchantPattern: 'Info:\\s+([A-Za-z0-9\\s\\-*]+?)(?:\\.|$)',
        
        // "on Nov 24, 2025 at 07:05:19" or "on Sep 19, 2025 at 08:14:10"
        // Captures month abbr, day, year and time (24-hour format)
        datePattern: 'on\\s+([A-Z][a-z]{2}\\s+\\d{2},\\s+\\d{4})\\s+at\\s+(\\d{2}:\\d{2}:\\d{2})',
        
        dateFormat: 'MMM DD, YYYY',
      },

      // ============================================
      // OneCard - Credit Card
      // ============================================
      {
        name: 'OneCard Credit Card',
        senderPattern: 'no-reply@getonecard\\.app',
        subjectPattern: 'Payment update on your Federal One credit card',
        bodyPattern: 'Your Federal One Credit Card ending',
        
        // "*Amount:* INR 230.46" or "Amount: INR 2,071.00"
        // Handles with/without asterisks, commas, and decimals
        amountPattern: '\\*?Amount[:\\s*]+INR[\\s]+([\\d,]+(?:\\.\\d{2})?)',
        
        // "ending in 1234" - will be auto-prefixed with XX
        accountPattern: 'ending in\\s+(\\d{4})',
        
        // "*Merchant:* MERCHANT.COM" or "Merchant: STORE* TRANSACTION123"
        // Handles asterisks, alphanumeric, special chars, dots
        merchantPattern: '\\*?Merchant[:\\s*]+([A-Za-z0-9*.][A-Za-z0-9*.\\s-]*?)\\s*(?:\\r?\\n|-{5,}|$)',
        
        // "*Date:* 31/07/2025" and "*Time:* 11:30:18"
        // Handles asterisks and dash separators between fields
        datePattern: '\\*?Date[:\\s*]+(\\d{2}/\\d{2}/\\d{4})\\s*(?:\\r?\\n|-+\\s*\\r?\\n)*\\s*\\*?Time[:\\s*]+(\\d{2}:\\d{2}:\\d{2})',
        
        dateFormat: 'DD-MM-YYYY', // Parser will handle / separator
      },
    ];
  }
  
  static getAllPatterns() {
    const defaultPatterns = BankPatternManager.getDefaultPatterns();
    
    // Check if user has custom patterns defined
    if (typeof getBankPatterns === 'function') {
      try {
        const customPatterns = getBankPatterns();
        return [...defaultPatterns, ...customPatterns];
      } catch (error) {
        console.log('No custom bank patterns found, using defaults only');
        return defaultPatterns;
      }
    }
    
    return defaultPatterns;
  }
}

// ==================== SERVICES ====================

/**
 * EmailService for Gmail operations
 */
class EmailService {
  constructor(logger) {
    this.logger = logger;
  }
  
  searchEmails(searchQuery, maxResults = 50) {
    try {
      this.logger.info(`Searching emails with query: ${searchQuery}`);
      const threads = GmailApp.search(searchQuery, 0, maxResults);
      this.logger.info(`Found ${threads.length} email threads`);
      return threads;
    } catch (error) {
      this.logger.error(`Error searching emails: ${error.message}`);
      throw new Error(`Failed to search emails: ${error.message}`);
    }
  }
  
  getMessagesFromThread(thread) {
    try {
      return thread.getMessages();
    } catch (error) {
      this.logger.error(`Error getting messages from thread: ${error.message}`);
      throw new Error(`Failed to get messages: ${error.message}`);
    }
  }
  
  extractEmailData(message) {
    try {
      let body = message.getPlainBody();
      
      // Check if plain body is empty, null, or the literal string "null"
      const isPlainBodyEmpty = !body || body.trim() === '' || body.trim().toLowerCase() === 'null';
      
      if (isPlainBodyEmpty) {
        this.logger.debug('Plain body empty/null, extracting from HTML...');
        const htmlBody = message.getBody();
        
        if (htmlBody && htmlBody.trim() !== '') {
          // Strip HTML tags
          body = this.stripHtmlTags(htmlBody);
          this.logger.debug(`Extracted ${body.length} chars from HTML`);
        } else {
          body = '';
        }
      }
      
      return {
        id: message.getId(),
        from: message.getFrom(),
        subject: message.getSubject(),
        body: body || '',
        date: message.getDate()
      };
    } catch (error) {
      this.logger.error(`Error extracting email data: ${error.message}`);
      throw new Error(`Failed to extract email data: ${error.message}`);
    }
  }
  
  stripHtmlTags(html) {
    if (!html) return '';
    
    try {
      return html
        .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '') // Remove style blocks
        .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '') // Remove script blocks
        .replace(/<br\s*\/?>/gi, '\n') // Convert <br> to newlines
        .replace(/<\/p>/gi, '\n') // Convert </p> to newlines
        .replace(/<\/div>/gi, '\n') // Convert </div> to newlines
        .replace(/<[^>]+>/g, ' ') // Remove all other HTML tags
        .replace(/&nbsp;/gi, ' ') // Replace &nbsp;
        .replace(/&amp;/gi, '&') // Replace &amp;
        .replace(/&lt;/gi, '<') // Replace &lt;
        .replace(/&gt;/gi, '>') // Replace &gt;
        .replace(/&quot;/gi, '"') // Replace &quot;
        .replace(/&#39;/gi, "'") // Replace &#39;
        .replace(/&#8377;/gi, 'â‚¹') // Replace &#8377; (rupee symbol)
        .replace(/\s*\n\s*/g, '\n') // Clean up newlines
        .replace(/\n{3,}/g, '\n\n') // Max 2 consecutive newlines
        .replace(/ {2,}/g, ' ') // Normalize spaces
        .trim();
    } catch (error) {
      this.logger.error(`Error stripping HTML: ${error.message}`);
      return html;
    }
  }
  
  markAsRead(message) {
    try {
      message.markRead();
      return true;
    } catch (error) {
      this.logger.error(`Error marking email as read: ${error.message}`);
      return false;
    }
  }
}

/**
 * SheetService for Google Sheets operations
 */
class SheetService {
  constructor(sheetId, sheetName, logger, nicknameManager) {
    this.sheetId = sheetId;
    this.sheetName = sheetName;
    this.logger = logger;
    this.nicknameManager = nicknameManager;
    this.spreadsheet = null;
    this.sheet = null;
  }
  
  initialize() {
    try {
      this.spreadsheet = SpreadsheetApp.openById(this.sheetId);
      this.sheet = this.spreadsheet.getSheetByName(this.sheetName);
      
      if (!this.sheet) {
        this.logger.info(`Sheet "${this.sheetName}" not found, creating...`);
        this.sheet = this.createSheet();
      }
      
      return this.sheet;
    } catch (error) {
      this.logger.error(`Error initializing sheet: ${error.message}`);
      throw new Error(`Failed to initialize sheet: ${error.message}`);
    }
  }
  
  createSheet() {
    try {
      const sheet = this.spreadsheet.insertSheet(this.sheetName);
      this.setupHeaders(sheet);
      return sheet;
    } catch (error) {
      this.logger.error(`Error creating sheet: ${error.message}`);
      throw new Error(`Failed to create sheet: ${error.message}`);
    }
  }
  
  setupHeaders(sheet) {
    const headers = SHEET_HEADERS;
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    
    const headerRange = sheet.getRange(1, 1, 1, headers.length);
    headerRange.setFontWeight(HEADER_STYLE.fontWeight);
    headerRange.setBackground(HEADER_STYLE.backgroundColor);
    headerRange.setFontColor(HEADER_STYLE.fontColor);
    sheet.setFrozenRows(1);
    
    this.setColumnWidths(sheet);
    this.logger.info('Sheet headers created and formatted');
  }
  
  setColumnWidths(sheet) {
    const widths = [100, 80, 100, 150, 180, 300, 150, 250];
    widths.forEach((width, index) => {
      sheet.setColumnWidth(index + 1, width);
    });
  }
  
  getProcessedEmailIds() {
    try {
      if (!this.sheet) this.initialize();
      
      const lastRow = this.sheet.getLastRow();
      if (lastRow <= 1) return new Set();
      
      const emailIds = this.sheet.getRange(2, 8, lastRow - 1, 1).getValues();
      return new Set(emailIds.map(row => row[0]).filter(id => id));
    } catch (error) {
      this.logger.error(`Error getting processed email IDs: ${error.message}`);
      return new Set();
    }
  }
  
  appendTransaction(transaction, emailId) {
    try {
      if (!this.sheet) this.initialize();
      
      const row = this.formatTransactionRow(transaction, emailId);
      
      // Append at bottom for chronological order (oldest first, newest last)
      this.sheet.appendRow(row);
      
      // Format the amount column
      const lastRow = this.sheet.getLastRow();
      this.sheet.getRange(lastRow, 3).setNumberFormat(AMOUNT_FORMAT);
      
      this.logger.info(`Transaction appended: ${transaction.merchant} - ${transaction.amount}`);
      return true;
    } catch (error) {
      this.logger.error(`Error appending transaction: ${error.message}`);
      return false;
    }
  }
  
  formatTransactionRow(transaction, emailId) {
    const date = transaction.datetime || new Date();
    const timezone = getTimezone();
    const accountNickname = this.nicknameManager 
      ? this.nicknameManager.getAccountNickname(transaction.account || '', transaction.source || '')
      : '';
    
    return [
      Utilities.formatDate(date, timezone, 'dd-MMM-yyyy'),
      Utilities.formatDate(date, timezone, 'HH:mm:ss'),
      transaction.amount,
      transaction.account || 'N/A',
      accountNickname || '',
      transaction.merchant || 'N/A',
      transaction.source || 'Unknown',
      emailId
    ];
  }
  
  getSheet() {
    if (!this.sheet) this.initialize();
    return this.sheet;
  }
}

/**
 * TransactionParser for parsing transaction emails
 */
class TransactionParser {
  constructor(logger) {
    this.logger = logger;
    this.patterns = BankPatternManager.getAllPatterns();
  }
  
  parseEmail(emailData) {
    this.logger.debug(`Parsing email from: ${emailData.from}`);
    this.logger.debug(`Subject: ${emailData.subject}`);
    
    const pattern = this.findMatchingPattern(emailData);
    if (!pattern) {
      this.logger.warn('No matching pattern found for email');
      return null;
    }
    
    this.logger.info(`Matched pattern: ${pattern.name}`);
    const transaction = this.extractTransaction(emailData, pattern);
    
    if (!transaction) {
      this.logger.warn('Failed to extract transaction data');
      return null;
    }
    
    return transaction;
  }
  
  findMatchingPattern(emailData) {
    for (const pattern of this.patterns) {
      if (this.isPatternMatch(emailData, pattern)) {
        return pattern;
      }
    }
    return null;
  }
  
  isPatternMatch(emailData, pattern) {
    const senderMatch = pattern.senderPattern 
      ? new RegExp(pattern.senderPattern, 'i').test(emailData.from)
      : false;
    const subjectMatch = pattern.subjectPattern
      ? new RegExp(pattern.subjectPattern, 'i').test(emailData.subject)
      : false;
    
    this.logger.debug(`Testing pattern: ${pattern.name}`);
    this.logger.debug(`  Sender match: ${senderMatch} (pattern: ${pattern.senderPattern})`);
    this.logger.debug(`  Subject match: ${subjectMatch} (pattern: ${pattern.subjectPattern})`);
    
    // Basic match: sender OR subject
    const basicMatch = senderMatch || subjectMatch;
    
    // If bodyPattern is specified, it MUST also match (additional validation)
    if (basicMatch && pattern.bodyPattern) {
      const bodyMatch = new RegExp(pattern.bodyPattern, 'i').test(emailData.body);
      this.logger.debug(`  Body match: ${bodyMatch} (pattern: ${pattern.bodyPattern})`);
      return bodyMatch;
    }
    
    return basicMatch;
  }
  
  extractTransaction(emailData, pattern) {
    const transaction = {
      datetime: null,
      amount: null,
      account: null,
      merchant: null,
      source: pattern.name
    };

    if (pattern.amountPattern) {
      transaction.amount = this.extractField(emailData.body, pattern.amountPattern, TextUtils.normalizeAmount);
    }
    if (pattern.accountPattern) {
      let account = this.extractField(emailData.body, pattern.accountPattern, TextUtils.cleanText);
      // Add XX prefix if it's just 4 digits (and doesn't already have XX)
      if (account && /^\d{4}$/.test(account)) {
        account = 'XX' + account;
      }
      transaction.account = account;
    }
    if (pattern.merchantPattern) {
      transaction.merchant = this.extractField(emailData.body, pattern.merchantPattern, TextUtils.cleanText);
    }
    if (pattern.datePattern) {
      // Pass date format to parser
      transaction.datetime = this.extractField(
        emailData.body,
        pattern.datePattern,
        (dateStr) => DateUtils.parseDate(dateStr, pattern.dateFormat)
      );
    }
    
    if (!transaction.datetime) {
      transaction.datetime = emailData.date;
    }
    
    if (!transaction.amount) {
      this.logger.warn('Transaction missing amount');
      return null;
    }
    
    return transaction;
  }
  
  extractField(text, pattern, formatter) {
    try {
      const match = text.match(new RegExp(pattern, 'i'));
      if (match) {
        let value;
        
        // Check if we have multiple capture groups
        if (match.length > 2) {
          // Find the first non-null captured group (skip match[0] which is full match)
          for (let i = 1; i < match.length; i++) {
            if (match[i]) {
              value = match[i];
              // For date patterns, check if next group is time
              if (i + 1 < match.length && match[i + 1] && /^\d{2}:\d{2}/.test(match[i + 1])) {
                value = match[i] + ' ' + match[i + 1];
              }
              break;
            }
          }
        } else {
          // Single capture group
          value = match[1] || match[0];
        }
        
        this.logger.debug(`Extracted value: "${value}" using pattern: ${pattern}`);
        return formatter ? formatter(value) : value;
      }
      // Enhanced debug: show portion of text around where we expected to find match
      const patternKey = pattern.substring(0, 20);
      const textSample = text.substring(0, 200);
      this.logger.debug(`No match found for pattern: ${pattern}`);
      this.logger.debug(`Text sample (first 200 chars): ${textSample}`);
      return null;
    } catch (error) {
      this.logger.error(`Error extracting field with pattern "${pattern}": ${error.message}`);
      return null;
    }
  }
}

/**
 * QueryBuilder for building Gmail search queries
 */
class QueryBuilder {
  constructor(logger) {
    this.logger = logger;
  }
  
  buildFromPatterns(patterns, searchDays) {
    const senders = this.extractSenders(patterns);
    const subjectPhrases = this.extractSubjectPhrases(patterns);
    
    const queryParts = [];
    if (senders.length > 0) queryParts.push(`from:(${senders.join(' OR ')})`);
    if (subjectPhrases.length > 0) queryParts.push(`subject:(${subjectPhrases.join(' OR ')})`);
    queryParts.push(`newer_than:${searchDays}d`);
    
    const query = queryParts.join(' ');
    this.logger.debug(`Built search query: ${query}`);
    return query;
  }
  
  extractSenders(patterns) {
    const senders = [];
    patterns.forEach(pattern => {
      if (pattern.senderPattern) {
        // Split by | to get multiple sender patterns
        const senderEmails = pattern.senderPattern.split('|');
        
        senderEmails.forEach(email => {
          // Clean up the regex syntax to get the actual email
          const cleanEmail = email
            .replace(/\\/g, '') // Remove backslashes
            .trim();
          
          if (cleanEmail.includes('@')) {
            senders.push(cleanEmail);
          }
        });
      }
    });
    return [...new Set(senders)];
  }
  
  extractSubjectPhrases(patterns) {
    const phrases = [];
    
    patterns.forEach(pattern => {
      if (pattern.subjectPattern) {
        // Split by | to get individual phrase patterns
        const individualPatterns = pattern.subjectPattern.split('|');
        
        individualPatterns.forEach(subPattern => {
          // Clean up regex syntax and get the actual phrase
          let phrase = subPattern
            .replace(/\\/g, '') // Remove backslashes
            .replace(/\.\*\?/g, '') // Remove .*?
            .replace(/\\s\+/g, ' ') // Replace \s+ with space
            .replace(/\\s/g, ' ') // Replace \s with space
            .replace(/[\(\)\[\]\{\}]/g, '') // Remove grouping brackets
            .trim();
          
          // Only add if it's a meaningful phrase (not just regex)
          if (phrase.length > 0 && phrase.split(' ').length >= 2) {
            // Wrap in quotes for exact phrase matching in Gmail
            phrases.push(`"${phrase}"`);
          }
        });
      }
    });
    
    return phrases;
  }
}

// ==================== SERVICE INITIALIZATION ====================

/**
 * Factory for initializing all services
 */
class ServiceFactory {
  static initialize() {
    const logger = new Logger(LOG_LEVEL);
    const spreadsheet = SpreadsheetApp.openById(SHEET_ID);
    const emailService = new EmailService(logger);
    const nicknameManager = new NicknameManager(spreadsheet, logger);
    const sheetService = new SheetService(SHEET_ID, SHEET_NAME, logger, nicknameManager);
    const transactionParser = new TransactionParser(logger);
    const queryBuilder = new QueryBuilder(logger);
    
    // Initialize nickname manager
    nicknameManager.initialize();
    
    return { logger, emailService, sheetService, transactionParser, queryBuilder, nicknameManager };
  }
}

// ==================== MAIN FUNCTIONS ====================
// These are the primary functions users will run

/**
 * Main automation function - processes transaction emails and adds to sheet
 * This function is called automatically every 10 minutes by the trigger
 * You can also run it manually anytime
 * 
 * @returns {Object} Result with success status, totalEmails, and newTransactions
 */
function processTransactionEmails() {
  const services = ServiceFactory.initialize();
  const { logger, emailService, sheetService, transactionParser, queryBuilder } = services;
  
  try {
    logger.section('TransacFlow - Processing Transaction Emails');
    
    sheetService.initialize();
    const processedEmailIds = sheetService.getProcessedEmailIds();
    logger.info(`Already processed: ${processedEmailIds.size} transactions`);
    
    const searchQuery = SEARCH_QUERY_MODE === 'DYNAMIC'
      ? queryBuilder.buildFromPatterns(BankPatternManager.getAllPatterns(), EMAIL_SEARCH_DAYS)
      : getSearchQuery();
    
    const threads = emailService.searchEmails(searchQuery, MAX_EMAILS_PER_RUN);
    
    if (threads.length === 0) {
      logger.info('No new emails found matching the query');
      return { success: true, totalEmails: 0, newTransactions: 0 };
    }
    
    let emailsProcessed = 0;
    const newTransactionsList = []; // Collect all new transactions
    const messagesToMarkRead = []; // Track messages to mark as read
    
    threads.forEach(thread => {
      const messages = emailService.getMessagesFromThread(thread);
      messages.forEach(message => {
        const emailData = emailService.extractEmailData(message);
        
        if (processedEmailIds.has(emailData.id)) {
          logger.debug(`Skipping already processed email: ${emailData.id}`);
          return;
        }
        
        emailsProcessed++;
        const transaction = transactionParser.parseEmail(emailData);
        
        if (transaction) {
          newTransactionsList.push({
            transaction: transaction,
            emailId: emailData.id,
            message: message
          });
        }
      });
    });
    
    // Sort transactions by datetime (oldest first)
    // Append in chronological order: oldest at top, newest at bottom
    newTransactionsList.sort((a, b) => {
      const dateA = a.transaction.datetime || new Date(0);
      const dateB = b.transaction.datetime || new Date(0);
      return dateA - dateB; // Ascending order (oldest first)
    });
    
    // Append all transactions in chronological order
    let newTransactions = 0;
    newTransactionsList.forEach(item => {
      if (sheetService.appendTransaction(item.transaction, item.emailId)) {
        newTransactions++;
        if (MARK_EMAILS_AS_READ) {
          emailService.markAsRead(item.message);
        }
      }
    });
    
    logger.section('Processing Complete');
    logger.success(`Processed ${emailsProcessed} emails`);
    logger.success(`Added ${newTransactions} new transactions in chronological order`);
    
    return { success: true, totalEmails: emailsProcessed, newTransactions: newTransactions };
    
  } catch (error) {
    logger.error(`Fatal error: ${error.message}`);
    if (SEND_ERROR_NOTIFICATIONS) {
      MailApp.sendEmail({
        to: Session.getActiveUser().getEmail(),
        subject: 'TransacFlow Error',
        body: `Error processing transactions: ${error.message}`
      });
    }
    throw error;
  }
}

/**
 * Setup function - validates config and creates the automation trigger
 * Run this once to set up TransacFlow
 * 
 * Steps:
 * 1. Validates configuration in Config.gs
 * 2. Tests connection to Google Sheet
 * 3. Creates trigger to run every 10 minutes
 */
function setupAutomation() {
  const logger = new Logger(LOG_LEVEL);
  logger.section('TransacFlow Setup');
  
  if (!validateConfig()) {
    logger.error('Configuration validation failed. Please fix errors in Config.gs');
    return;
  }
  
  logger.info('Configuration validated âœ“');
  
  try {
    const sheet = SpreadsheetApp.openById(SHEET_ID);
    logger.success(`Connected to sheet: ${sheet.getName()}`);
  } catch (error) {
    logger.error(`Cannot access sheet with ID: ${SHEET_ID}`);
    logger.error('Please check SHEET_ID in Config.gs');
    return;
  }
  
  TriggerManager.create();
  
  logger.section('Setup Complete!');
  logger.success('TransacFlow is now active');
  logger.info('Run processTransactionEmails() to test immediately');
}

// ==================== INTERNAL MANAGERS ====================
// These classes encapsulate internal logic and are not shown in dropdown

/**
 * Manager for account nicknames (stored in separate sheet)
 */
class NicknameManager {
  constructor(spreadsheet, logger) {
    this.spreadsheet = spreadsheet;
    this.logger = logger;
    this.sheet = null;
    this.cache = new Map();
    this.nicknamesSheetName = typeof NICKNAMES_SHEET_NAME !== 'undefined' ? NICKNAMES_SHEET_NAME : 'Account Nicknames';
  }
  
  initialize() {
    try {
      this.sheet = this.spreadsheet.getSheetByName(this.nicknamesSheetName);
      
      if (!this.sheet) {
        this.logger.info(`Creating "${this.nicknamesSheetName}" sheet...`);
        this.sheet = this.createNicknamesSheet();
      }
      
      // Load nicknames into cache
      this.loadCache();
      return this.sheet;
    } catch (error) {
      this.logger.error(`Error initializing nicknames sheet: ${error.message}`);
      throw error;
    }
  }
  
  createNicknamesSheet() {
    const sheet = this.spreadsheet.insertSheet(this.nicknamesSheetName);
    
    // Setup headers
    const headers = ['Account/Card/UPI', 'Auto-Generated Name', 'Custom Nickname', 'Last Updated'];
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    
    // Style header
    const headerRange = sheet.getRange(1, 1, 1, headers.length);
    headerRange.setFontWeight('bold');
    headerRange.setBackground('#34a853'); // Green
    headerRange.setFontColor('#ffffff');
    sheet.setFrozenRows(1);
    
    // Set column widths
    sheet.setColumnWidth(1, 180); // Account
    sheet.setColumnWidth(2, 250); // Auto-generated
    sheet.setColumnWidth(3, 250); // Custom
    sheet.setColumnWidth(4, 150); // Last Updated
    
    // Add instructions in row 2
    sheet.getRange(2, 1, 1, 4).setValues([[
      'Instructions â†’',
      'This is auto-generated',
      'Edit this column to customize names',
      'Auto-updated'
    ]]);
    sheet.getRange(2, 1, 1, 4).setFontStyle('italic').setBackground('#f3f3f3');
    
    this.logger.success('Account Nicknames sheet created');
    return sheet;
  }
  
  loadCache() {
    if (!this.sheet) return;
    
    const lastRow = this.sheet.getLastRow();
    if (lastRow < 3) return; // No data (headers + instructions only)
    
    const data = this.sheet.getRange(3, 1, lastRow - 2, 3).getValues();
    data.forEach(row => {
      const [account, autoName, customName] = row;
      if (account) {
        this.cache.set(account, {
          autoName: autoName || '',
          customName: customName || ''
        });
      }
    });
    
    this.logger.debug(`Loaded ${this.cache.size} account nicknames into cache`);
  }
  
  getAccountNickname(accountNumber, source) {
    if (!accountNumber) return '';
    
    // Check cache first
    if (this.cache.has(accountNumber)) {
      const { autoName, customName } = this.cache.get(accountNumber);
      return customName || autoName || '';
    }
    
    // Generate auto name
    const autoName = this.generateAutoName(accountNumber, source);
    
    // Add to sheet and cache (async, non-blocking)
    this.addAccountIfNew(accountNumber, autoName, source);
    
    return autoName;
  }
  
  generateAutoName(accountNumber, source) {
    if (!source) return accountNumber;
    
    const last4 = accountNumber.replace(/^XX/, '').slice(-4);
    return `${source} (${last4})`;
  }
  
  addAccountIfNew(accountNumber, autoName, source) {
    if (!this.sheet || this.cache.has(accountNumber)) return;
    
    try {
      // Add to cache immediately
      this.cache.set(accountNumber, {
        autoName: autoName,
        customName: ''
      });
      
      // Add to sheet
      const timestamp = new Date();
      this.sheet.appendRow([
        accountNumber,
        autoName,
        '', // Empty custom nickname
        Utilities.formatDate(timestamp, getTimezone(), 'dd-MMM-yyyy HH:mm:ss')
      ]);
      
      this.logger.debug(`Added new account to nicknames sheet: ${accountNumber}`);
    } catch (error) {
      this.logger.error(`Error adding account to nicknames sheet: ${error.message}`);
    }
  }
  
  updateTransactionsWithNickname(accountNumber, newNickname) {
    try {
      const transSheet = this.spreadsheet.getSheetByName(SHEET_NAME);
      if (!transSheet) return 0;
      
      const lastRow = transSheet.getLastRow();
      if (lastRow <= 1) return 0;
      
      // Get all data
      const dataRange = transSheet.getRange(2, 1, lastRow - 1, 8);
      const data = dataRange.getValues();
      
      let updatedCount = 0;
      
      // Update matching rows
      for (let i = 0; i < data.length; i++) {
        if (data[i][3] === accountNumber) { // Column 4 (index 3) is Account/Card/UPI
          data[i][4] = newNickname; // Column 5 (index 4) is Account Name
          updatedCount++;
        }
      }
      
      if (updatedCount > 0) {
        dataRange.setValues(data);
        this.logger.success(`Updated ${updatedCount} transactions with new nickname`);
      }
      
      return updatedCount;
    } catch (error) {
      this.logger.error(`Error updating transactions: ${error.message}`);
      return 0;
    }
  }
}

/**
 * Manager for automation triggers
 */
class TriggerManager {
  static create() {
    const logger = new Logger(LOG_LEVEL);
    
    // Remove existing triggers
    const existingTriggers = ScriptApp.getProjectTriggers();
    existingTriggers.forEach(trigger => {
      const handlerFunc = trigger.getHandlerFunction();
      if (handlerFunc === 'processTransactionEmails' || handlerFunc === 'onNicknameEdit') {
        ScriptApp.deleteTrigger(trigger);
        logger.info(`Removed existing trigger: ${handlerFunc}`);
      }
    });
    
    // Create time-based trigger for automation
    ScriptApp.newTrigger('processTransactionEmails')
      .timeBased()
      .everyMinutes(10)
      .create();
    logger.success('Created time-based trigger: runs every 10 minutes');
    
    // Create onEdit trigger for nickname updates
    ScriptApp.newTrigger('onNicknameEdit')
      .forSpreadsheet(SHEET_ID)
      .onEdit()
      .create();
    logger.success('Created onEdit trigger: detects nickname changes');
  }
}

// ==================== TESTING FUNCTIONS ====================
// Use these to test email parsing before running the full automation

/**
 * TEST: Parse a single email and display the extracted data
 * 
 * What it does:
 * - Finds one matching email
 * - Shows email details (from, subject, date)
 * - Extracts transaction data
 * - Displays in console (does NOT write to sheet)
 * 
 * Use this to verify patterns are working correctly
 */
function test_SingleEmail() {
  const services = ServiceFactory.initialize();
  const { logger, emailService, transactionParser, queryBuilder } = services;
  
  logger.section('Testing Email Parsing');
  
  const patterns = BankPatternManager.getAllPatterns();
  const searchQuery = SEARCH_QUERY_MODE === 'DYNAMIC'
    ? queryBuilder.buildFromPatterns(patterns, EMAIL_SEARCH_DAYS)
    : getSearchQuery();
  
  logger.info(`Patterns loaded: ${patterns.length}`);
  logger.info(`Using search query: ${searchQuery}`);
  const threads = emailService.searchEmails(searchQuery, 1);
  
  if (threads.length === 0) {
    logger.warn('No emails found. Try adjusting the search query.');
    return;
  }
  
  const messages = emailService.getMessagesFromThread(threads[0]);
  const message = messages[0];
  const emailData = emailService.extractEmailData(message);
  
  logger.info('Email Details:');
  logger.info(`From: ${emailData.from}`);
  logger.info(`Subject: ${emailData.subject}`);
  logger.info(`Date: ${emailData.date}`);
  
  const transaction = transactionParser.parseEmail(emailData);
  
  if (transaction) {
    logger.section('Extracted Transaction');
    logger.object('Transaction Data', transaction);
  } else {
    logger.error('Could not parse transaction from email');
  }
}

/**
 * TEST: Parse a single email and write it to the sheet
 * 
 * What it does:
 * - Finds one matching email
 * - Extracts transaction data
 * - Writes to Google Sheet
 * - Shows transaction details in console
 * 
 * Use this to test the complete flow including sheet writing
 */
function test_WriteToSheet() {
  const services = ServiceFactory.initialize();
  const { logger, emailService, sheetService, transactionParser, queryBuilder } = services;
  
  logger.section('Testing Email Parsing & Sheet Writing');
  
  sheetService.initialize();
  
  const patterns = BankPatternManager.getAllPatterns();
  const searchQuery = SEARCH_QUERY_MODE === 'DYNAMIC'
    ? queryBuilder.buildFromPatterns(patterns, EMAIL_SEARCH_DAYS)
    : getSearchQuery();
  
  logger.info(`Patterns loaded: ${patterns.length}`);
  logger.info(`Using search query: ${searchQuery}`);
  const threads = emailService.searchEmails(searchQuery, 1);
  
  if (threads.length === 0) {
    logger.warn('No emails found');
    return false;
  }
  
  const messages = emailService.getMessagesFromThread(threads[0]);
  const message = messages[0];
  const emailData = emailService.extractEmailData(message);
  
  logger.info(`Testing with email from: ${emailData.from}`);
  const transaction = transactionParser.parseEmail(emailData);
  
  if (transaction) {
    logger.object('Transaction Data', transaction);
    if (sheetService.appendTransaction(transaction, emailData.id)) {
      logger.success('Transaction written to sheet!');
      return true;
    } else {
      logger.error('Failed to write transaction to sheet');
      return false;
    }
  } else {
    logger.error('Could not parse transaction');
    return false;
  }
}

// ==================== NICKNAME TRIGGER FUNCTION ====================

/**
 * Trigger function called when user edits the Account Nicknames sheet
 * Automatically updates all transactions with the new nickname
 * 
 * @internal - Installed by setupAutomation()
 */
function onNicknameEdit(e) {
  try {
    // Check if edit is in Account Nicknames sheet
    const nicknamesSheetName = typeof NICKNAMES_SHEET_NAME !== 'undefined' ? NICKNAMES_SHEET_NAME : 'Account Nicknames';
    const sheet = e.source.getActiveSheet();
    if (sheet.getName() !== nicknamesSheetName) return;
    
    const range = e.range;
    const row = range.getRow();
    const col = range.getColumn();
    
    // Check if edit is in "Custom Nickname" column (column 3) and not in header rows
    if (col !== 3 || row <= 2) return;
    
    const logger = new Logger(LOG_LEVEL);
    const spreadsheet = e.source;
    const nicknameManager = new NicknameManager(spreadsheet, logger);
    nicknameManager.sheet = sheet;
    
    // Get the account number and new nickname
    const accountNumber = sheet.getRange(row, 1).getValue();
    const newNickname = sheet.getRange(row, 3).getValue();
    
    // Use auto-generated name if custom nickname is empty
    const finalNickname = newNickname || sheet.getRange(row, 2).getValue();
    
    // Update timestamp
    sheet.getRange(row, 4).setValue(
      Utilities.formatDate(new Date(), getTimezone(), 'dd-MMM-yyyy HH:mm:ss')
    );
    
    // Update all transactions with this account
    const count = nicknameManager.updateTransactionsWithNickname(accountNumber, finalNickname);
    
    if (count > 0) {
      SpreadsheetApp.getActiveSpreadsheet().toast(
        `Updated ${count} transaction(s) with new nickname for ${accountNumber}`,
        'Nickname Updated',
        5
      );
    }
    
  } catch (error) {
    console.error(`Error in onNicknameEdit: ${error.message}`);
  }
}

// ==================== UTILITY FUNCTIONS ====================

/**
 * Manually refresh all account nicknames in the Transactions sheet
 * Run this if you want to update all existing transactions with latest nicknames
 * 
 * Use when: You've edited multiple nicknames and want to apply them all at once
 */
function refreshAllNicknames() {
  const logger = new Logger(LOG_LEVEL);
  
  try {
    logger.section('Refreshing All Account Nicknames');
    
    const spreadsheet = SpreadsheetApp.openById(SHEET_ID);
    const nicknameManager = new NicknameManager(spreadsheet, logger);
    nicknameManager.initialize();
    
    const transSheet = spreadsheet.getSheetByName(SHEET_NAME);
    if (!transSheet) {
      logger.error('Transactions sheet not found');
      return;
    }
    
    const lastRow = transSheet.getLastRow();
    if (lastRow <= 1) {
      logger.info('No transactions to update');
      return;
    }
    
    // Get all transaction data
    const dataRange = transSheet.getRange(2, 1, lastRow - 1, 8);
    const data = dataRange.getValues();
    
    let updatedCount = 0;
    
    // Update each row with latest nickname
    for (let i = 0; i < data.length; i++) {
      const accountNumber = data[i][3]; // Column 4 (index 3) is Account/Card/UPI
      const source = data[i][6]; // Column 7 (index 6) is Source
      
      if (accountNumber) {
        const nickname = nicknameManager.getAccountNickname(accountNumber, source);
        if (nickname && data[i][4] !== nickname) {
          data[i][4] = nickname; // Column 5 (index 4) is Account Name
          updatedCount++;
        }
      }
    }
    
    if (updatedCount > 0) {
      dataRange.setValues(data);
      logger.success(`Updated ${updatedCount} transaction(s) with latest nicknames`);
    } else {
      logger.info('All nicknames are already up to date');
    }
    
  } catch (error) {
    logger.error(`Error refreshing nicknames: ${error.message}`);
  }
}

// ==================== DIAGNOSTIC FUNCTIONS ====================
// Use these to troubleshoot issues with email search and patterns

/**
 * DEBUG: Show raw email content for debugging patterns
 * 
 * What it shows:
 * - Raw email from, subject, body
 * - Useful for creating/debugging regex patterns
 * 
 * Use this to see exact email content
 */
function debug_ShowRawEmail() {
  const logger = new Logger('DEBUG');
  
  logger.section('Raw Email Content Debugging');
  
  const patterns = BankPatternManager.getAllPatterns();
  const queryBuilder = new QueryBuilder(logger);
  const searchQuery = SEARCH_QUERY_MODE === 'DYNAMIC'
    ? queryBuilder.buildFromPatterns(patterns, EMAIL_SEARCH_DAYS)
    : getSearchQuery();
  
  console.log(`Search Query: ${searchQuery}`);
  
  const threads = GmailApp.search(searchQuery, 0, 1);
  
  if (threads.length === 0) {
    console.log('âŒ No emails found');
    return;
  }
  
  const messages = threads[0].getMessages();
  const message = messages[0];
  
  console.log('\n' + '='.repeat(60));
  console.log('FROM:');
  console.log(message.getFrom());
  
  console.log('\n' + '='.repeat(60));
  console.log('SUBJECT:');
  console.log(message.getSubject());
  
  console.log('\n' + '='.repeat(60));
  console.log('DATE:');
  console.log(message.getDate());
  
  // Check plain body
  console.log('\n' + '='.repeat(60));
  console.log('PLAIN BODY:');
  let plainBody = '';
  try {
    plainBody = message.getPlainBody();
    console.log(plainBody ? plainBody.substring(0, 1000) : 'âŒ NULL/EMPTY');
    console.log(`Length: ${plainBody ? plainBody.length : 0}`);
  } catch (e) {
    console.log(`âŒ Error getting plain body: ${e.message}`);
  }
  
  // Check HTML body
  console.log('\n' + '='.repeat(60));
  console.log('HTML BODY (First 500 chars):');
  let htmlBody = '';
  try {
    htmlBody = message.getBody();
    console.log(htmlBody ? htmlBody.substring(0, 500) : 'âŒ NULL/EMPTY');
    console.log(`Length: ${htmlBody ? htmlBody.length : 0}`);
  } catch (e) {
    console.log(`âŒ Error getting HTML body: ${e.message}`);
  }
  
  // Try extraction
  console.log('\n' + '='.repeat(60));
  console.log('EXTRACTED CONTENT (what TransacFlow will use):');
  
  let body = plainBody;
  const isPlainEmpty = !body || body.trim() === '' || body.trim().toLowerCase() === 'null';
  
  if (isPlainEmpty) {
    console.log('âš ï¸ Plain body is empty/null (detected literal "null" string), extracting from HTML...');
    
    if (htmlBody && htmlBody.trim() !== '') {
      const emailService = new EmailService(logger);
      body = emailService.stripHtmlTags(htmlBody);
      console.log(`âœ“ Successfully extracted from HTML (${body.length} chars)`);
    } else {
      console.log('âŒ HTML body is also empty/null!');
      body = '';
    }
  } else {
    console.log('âœ“ Using plain body');
  }
  
  console.log('\n' + '-'.repeat(60));
  console.log('FINAL CONTENT:');
  console.log(body ? body.substring(0, 1000) : 'âŒ EMPTY');
  console.log(`\nFinal Body Length: ${body ? body.length : 0}`);
  console.log('='.repeat(60));
}

/**
 * DEBUG: Diagnose email search issues
 * 
 * What it shows:
 * - All loaded bank patterns
 * - Current search query being used
 * - Sample emails found (up to 5)
 * - Troubleshooting suggestions if no emails found
 * 
 * Use this when emails aren't being found
 */
function debug_EmailSearch() {
  const logger = new Logger('DEBUG');
  const patterns = BankPatternManager.getAllPatterns();
  
  logger.section('Email Search Diagnostics');
  logger.info(`Bank Patterns Loaded: ${patterns.length}`);
  patterns.forEach(p => logger.info(`  - ${p.name}`));
  
  const searchQuery = SEARCH_QUERY_MODE === 'DYNAMIC'
    ? new QueryBuilder(logger).buildFromPatterns(patterns, EMAIL_SEARCH_DAYS)
    : getSearchQuery();
  
  logger.info(`\nActive Query: ${searchQuery}`);
  logger.info(`Mode: ${SEARCH_QUERY_MODE}`);
  logger.info(`Search Days: ${EMAIL_SEARCH_DAYS}`);
  
  try {
    const threads = GmailApp.search(searchQuery, 0, 10);
    logger.success(`\nFound ${threads.length} email threads`);
    
    if (threads.length > 0) {
      logger.section('Sample Emails Found');
      threads.slice(0, 5).forEach((thread, index) => {
        const message = thread.getMessages()[0];
        logger.info(`${index + 1}. From: ${message.getFrom()}`);
        logger.info(`   Subject: ${message.getSubject()}`);
        logger.info(`   Date: ${message.getDate()}`);
      });
    } else {
      logger.warn('\nNo emails found. Try:');
      logger.warn('  1. Check if you have transaction emails in last ${EMAIL_SEARCH_DAYS} days');
      logger.warn('  2. Increase EMAIL_SEARCH_DAYS in Config.gs');
      logger.warn('  3. Verify bank patterns match your email format');
    }
  } catch (error) {
    logger.error(`Search failed: ${error.message}`);
  }
}

/**
 * DEBUG: Show current search query and loaded banks
 * 
 * What it shows:
 * - Search mode (DYNAMIC or MANUAL)
 * - Complete search query
 * - List of all loaded bank patterns
 * 
 * Use this to verify which banks are being searched for
 */
function debug_SearchQuery() {
  const logger = new Logger('INFO');
  const queryBuilder = new QueryBuilder(logger);
  const patterns = BankPatternManager.getAllPatterns();
  
  logger.section('Current Search Query');
  logger.info(`Total Bank Patterns Loaded: ${patterns.length}`);
  
  if (SEARCH_QUERY_MODE === 'DYNAMIC') {
    const query = queryBuilder.buildFromPatterns(patterns, EMAIL_SEARCH_DAYS);
    logger.info('Mode: DYNAMIC (auto-generated from bank patterns)');
    logger.info(`Query: ${query}`);
    logger.info('\nLoaded Banks:');
    patterns.forEach(p => logger.info(`  - ${p.name}`));
  } else {
    logger.info('Mode: MANUAL');
    logger.info(`Query: ${getSearchQuery()}`);
  }
}


